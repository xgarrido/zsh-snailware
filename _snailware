# -*- mode: shell-script; -*-
#compdef snailware

# Global variables; setup the first time _snailware is called.
# For $_snailware_commands[] generation, see the very end of this file.
typeset -ga _snailware_commands _snailware_aliases
typeset -gA _snailware_aliasmap
typeset -ga _snailware_components

_snailware_aliasmap=(
    up    svn-update
    setup setup
    conf  configure
    build build
    reset reset
    test  test
    st    svn-status
    diff  svn-diff
    co    svn-checkout
    go    goto
)

_snailware_components=(
    'all'
    'bayeux'
    'datatools'
    'brio'
    'cuts'
    'mygsl'
    'geomtools'
    'genvtx'
    'materials'
    'genbb_help'
    'trackfit'
    'channel'
    'TrackerPreClustering'
    'CellularAutomatonTracker'
    'TrackerClusterPath'
    'falaise'
    'sngeometry'
    'sncore'
    'sngenvertex'
    'sngenbb'
    'sng4'
    'snreconstruction'
    'snvisualization'
    'snanalysis'
    'extra'
    'matacqana'
    'bipoanalysis'
    'bipovisualization'
)

# --- Sub-command functions ---
# These *must* be called _snailware-*(); The description generation relies on
# them being names that way. *No* other functions may match that pattern.
# Other utility functions should be named __snailware-*() (see below).
#
# Another thing, the description generation needs, is handling of
# $snailware_describe: If that parameter is non-empty, the sub-command function
# should only print a description of the sub-command it handles and return
# immidiately after doing so.
#
# To add support for a new sub-command, you only have to add a new
# _snailware-<foo>() function below (preferably alphabetically sorted), that
# behaves like described above; and add a alias->command pair in the
# _snailware_aliasmap associative array above (if the comand in fact has an
# alias). The rest should just work[tm].

function _snailware-build ()
{
    [[ -n ${snailware_describe} ]] && print "Build a component" && return
    __snailware-choose-component
}

function _snailware-configure ()
{
    [[ -n ${snailware_describe} ]] && print "Configure a component" && return
    local -a args

    args=(
        '--with-test[build with test (default)]'
        '--without-test[do not build test programs]'
        '--with-doc[build documentation]'
        '--without-doc[do not build documentation (default)]'
        '*:: :->'
    )
    _arguments ${args} && return
    __snailware-choose-component
}

function _snailware-goto ()
{
    [[ -n ${snailware_describe} ]] && print "Goto a component directory" && return
    __snailware-choose-component
}

function _snailware-rebuild ()
{
    [[ -n ${snailware_describe} ]] && print "Rebuild component from scratch" && return
    __snailware-choose-component
}

function _snailware-reset ()
{
    [[ -n ${snailware_describe} ]] && print "Reset component" && return
    __snailware-choose-component
}

function _snailware-setup ()
{
    [[ -n ${snailware_describe} ]] && print "Source a component" && return
    __snailware-choose-component
}

function _snailware-status ()
{
    [[ -n ${snailware_describe} ]] && print "Status of a component" && return
    __snailware-choose-component
}

function _snailware-svn-checkout ()
{
    [[ -n ${snailware_describe} ]] && print "SVN checkout a component" && return
    __snailware-choose-component
}

function _snailware-svn-diff ()
{
    [[ -n ${snailware_describe} ]] && print "SVN diff a component" && return
    __snailware-choose-component
}

function _snailware-svn-status ()
{
    [[ -n ${snailware_describe} ]] && print "SVN status of a component" && return
    __snailware-choose-component
}

function _snailware-svn-update ()
{
    [[ -n ${snailware_describe} ]] && print "SVN update a component" && return
    __snailware-choose-component
}

function _snailware-test ()
{
    [[ -n ${snailware_describe} ]] && print "Run tests on a component" && return
    __snailware-choose-component
}

# --- Utility functions ---
# They should be called __snailware-*() and kept seperate from the
# sub-command functions.

function __snailware-choose-component ()
{
    _describe -t _snailware_components 'SN@ailWare option' _snailware_components
}

# And here is the actual _snailware(), that puts it all together:
function _snailware() {
    local curcontext="${curcontext}"
    local mode state ret
    local -a args
    local -x snailwarecommand
    unset snailware_describe

    args=(
        '-h[print help]'
        '-d[debug mode]'
        '-D[devel mode]'
        '-v[verbose mode]'
        '-q[quiet mode]'
        '-i[interactive]'
        '-b[batch]'
        '-g[GUI mode]'
        '*:: :->subcommand_or_options'
    )
    _arguments -C -s -w ${args} && return

    if [[ ${state} == "subcommand_or_options" ]]; then
        if (( CURRENT == 1 )) ; then
            zstyle -s ":completion:${curcontext}:subcommands" mode mode || mode='commands'
            if [[ ${mode} == 'commands' ]]; then
                _describe -t subcommands 'snailware commands' _snailware_commands
            elif [[ ${mode} == 'aliases' ]]; then
                _describe -t subcommands 'snailware aliases' _snailware_aliases
            else
                _describe -t subcommands 'snailware commands and aliases' _snailware_commands -- _snailware_aliases
            fi
        else
            if (( ${+functions[snailware]} == 0 )); then
                _message '`snailware'\'' not found in $path; sub-cmd completions disabled.'
                return 0
            fi
            snailwarecommand="${words[1]}"
            if [[ -n ${_snailware_aliasmap[$snailwarecommand]} ]] ; then
                snailwarecommand="${_snailware_aliasmap[$snailwarecommand]}"
            fi
            if ! (( ${+functions[_snailware-$snailwarecommand]} )); then
              local low high
              low=$_snailware_commands[(i)$snailwarecommand*]
              high=$_snailware_commands[(I)$snailwarecommand*]
              if (( low == high )); then
                snailwarecommand=${_snailware_commands[low]%%:*}
              elif (( low < high )); then
                _message -e "Ambiguous command $snailwarecommand"
              else
                _message -e "Subcommand $snailwarecommand not known"
              fi
            fi
            curcontext="${curcontext%:*:*}:snailware-${snailwarecommand}:"
            _call_function ret _snailware-${snailwarecommand}
        fi
    fi
}

# description generation follows; only done on 1st _snailware call.
local f desc
local -A rev
local -x snailware_describe
snailware_describe='yes, please'
for f in ${(k)_snailware_aliasmap} ; do
    rev+=( ${_snailware_aliasmap[$f]} $f )
done
for f in ${(M)${(k)functions}:#_snailware-*} ; do
    desc="$($f)"
    _snailware_commands+=( "${f#_snailware-}${desc:+:$desc}" )
    [[ -n ${rev[${f#_snailware-}]} ]] && _snailware_aliases+=( "${rev[${f#_snailware-}]}${desc:+:$desc}" )
done
unset desc f rev snailware_describe

_snailware
